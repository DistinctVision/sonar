# Свой AR. Основы векторной алгебры.

В настоящий момент появилось достаточно большое количество библиотек дополненной реальности с богатым функционалом (ARCore, ARKit, Vuforia). Тем не менее я решил начать свой открытый проект, попутно описывая как это все работает изнутри. Если повезет, то позже получится добавить какой-то особый интересный функционал, которого нет в других библиотеках. В качестве целевых платформ пока возьмем Windows и Android. Библиотека пишется на C++, и сторонние библиотеки будут задействованы по минимуму, т.е. преимущественно не будет использовано ничего готового. Упор в статьях будет сделан на алгоритмы и математику, которые я постараюсь описать максимально доступно и подробно.

Дополненная реальность - это совмещение виртуального мира и реального. Для этого, нам нужно представить окружающее реального пространство в виде математической модели, понимая закономерности которой, мы сможем получить данные для совмещения. Начнем с векторной математики.

Вектора - это частный случай матриц, состоящие либо из одного столбца, либо из одной строки. Когда мы говорим вектор, обычно имеется вектор-столбец $\vec v = \begin{pmatrix}v_x \\ v_y \\ v_z \\v_w\end{pmatrix}$ (тут у нас 4-мерный вектор). Но записывать вектора как столбец неудобно, поэтому, записывая вектор, будем его транспонировать -- $\vec v = \begin{pmatrix}v_x & v_y & v_z & v_w\end{pmatrix}^T$.

### Длина вектора.
Первое, что на понадобится - получение длины вектора - $l = |\vec v|$, где $l$ - значение длины, $\vec v$ - наш вектор. Для примера пусть вектор будет двумерный:

![](./assets/Figure_1.png)

$\vec v = (x, y)^T$, где $x$ и $y$ - компоненты вектора, значения проекций вектора на оси двумерных координат. И мы видим прямоугольный треугольник, где $x$ и $y$ - это длины катетов, $l$ - выходит длина его гипотенузы. По теореме Пифагора получается, что $l = \sqrt{x^2 + y^2}$. Значит $l = |\vec v| = \sqrt{x^2 + y^2}$. Вид формулы сохраняется и для векторов большей размерности, например -- $l = |\vec v| = |\begin{pmatrix} x & y & z & w\end{pmatrix}^T| = \sqrt{x^2 + y^2 + z^2 + w^2}$.

### Скалярное произведение.
Теперь разберемся с тем, что такое скалярное произведение векторов. Это сумма произведение их компонентов: $s = \vec a \cdot \vec b = a_x \cdot b_x + a_y \cdot b_y + a_z \cdot b_z$. Но так как мы знаем, что вектора - это матрицы, то тогда удобнее записать это в таком виде: $s = \vec{a}^T \vec{b}$. Это же произведение можно записать в другом виде: $s = {\vec a}^T \cdot \vec b = |\vec a| \cdot |vec b| \cdot \cos(\delta)$, где $\delta$ - угол между векторами $\vec a$ и $\vec b$ (для двумерного случая эта формула доказывается через теорему косинусов). По этой формуле можно заключить, что скалярное произведение - это мера сонаправленности векторов. Ведь, если $\delta = 0^{\circ}$, то $\cos(\delta) = 1$, и $s$ - это просто произведение длин векторов. Так как $\cos(\delta)$ - не может быть больше 1, то это максимальное значение, которые мы можем получить, изменяя только угол $\delta$. Минимальное значение $\cos(\delta)$ будет равно -1, и получается при $\delta = 180^{\circ}$, т.е. когда вектора смотрят в противоположные направления. Также заметим, что при $\delta = 90^{\circ}$ $\cos(\delta)=0$, а значит какие бы длины не имели вектора $\vec a$ и $\vec b$ -- $s = 0$. Можно в таком случае сказать, что вектора не имеют общего направления, и называются ортогональными. 
Также при помощи скалярного произведения, мы можем записать формулу длины вектора красивее: $|\vec v| = \sqrt{\vec{v}^T \vec v}$.

### Проекция вектора на другой вектор

Возьмем два вектора: $\vec a$ и $\vec b$. 
Проекцию вектора на дргуой вектор можно рассматривать в двух смыслах: геометрическом и алгебраическом. В геометрическом смысле проекция вектора на ось - это вектор, а в алгебраическом – число. 

![](./assets/Figure_2.png)  
Вектора - это направаления, поэтому их начало лежит в начасле кооржинат. Обозначим ключевые точки: $O$ - исходная точка, $A$ - конечная точка вектора $\vec a$, $B$ - конечная точка вектора $\vec b$. 

В геометрическом смысле мы ищем такой $\vec c$, чтобы конечная точка вектора (обозначим ее как - $C$) была ближайшей точкой к точке $B$, лежащей на прямой $OA$.

Иначе говоря, мы хотим найти состовляющую $\vec b$ в $\vec a$, т.е. такое значение $t$, чтобы $\vec c = \vec a \cdot t$ и $|\vec c - \vec b| \rightarrow min$

Расстояние между точками $B$ и $C$ будет минимальным, если $\angle OCB = 90^\circ$. Получаем прямоуголный треугольник - $OCB$. Обозначим $\alpha = \angle COB$. Мы значем, что $\cos{\alpha} = \frac{|OC|}{|OB|}$ по определению косинуса через соотношение сторон прямоугольного треугольника ($OB$ - гипотенуза, $OC$ - прилежащий катет).
Также возьмем скалярное произведение $s = \vec a \cdot \vec b = |\vec a| \cdot |\vec b| \cdot \cos(\alpha)$. Отсюда следует, что $\cos(\alpha) = \frac {\vec a \cdot \vec b } {|\vec a| \cdot |\vec b|}$. А значит $\frac{|OC|}{|OB|} = \frac {\vec a \cdot \vec b } {|\vec a| \cdot |\vec b|}$. Тут вспоминаем, что $OC$ - это искомый вектор $\vec c$, а $OB$ - $\vec b$, и получаем $\frac{|\vec c|}{|\vec b|} = \frac {\vec a \cdot \vec b } {|\vec a| \cdot |\vec b|}$. Умножаем обе части на $|\vec b|$ и получаем - $|\vec c| = \frac {\vec a \cdot \vec b } {|\vec a|}$. Теперь мы знаем длину $\vec c$. Вектор $\vec c$ отличается от вектора $\vec a$ длинной, а значит через соотношение длин можно получить: $\vec c = \vec a \cdot \frac{|\vec c|}{|\vec a|^2}$. И мы можем вывести финальные формулы:  
$t = \frac {\vec a \cdot \vec b } {|\vec a|^2} = \frac {{\vec a}^T \vec b}{{\vec a}^T \vec a}$ и  
$\vec c = \vec a \cdot \frac {{\vec a}^T \vec b}{{\vec a}^T \vec a}$

### Нормализованный вектор.

Хороший способ упростить работу над векторами -- использовать вектора единичной длины. Возьмем вектор $\vec v$. Мы можем получить сонаправленный вектор $\vec nv$, который будет иметь единичную длину, для этого нужно просто вектор разделить на его длину: $\vec{nv} = \frac{\vec v}{|\vec v|}$. Эта операция называется нормализацией.  
Зная нормализованный вектор и длину исходного вектора, можно получить исходный вектор: $\vec v = \vec{nv} \cdot |\vec v|$.
Зная нормализованный вектор и исходный вектор, можно получить его длину: $|vec v| = {\vec v}^T \vec{nv}$.
Хорошим преимуществом нормализованных векторов является то, что сильно упрощается формула проекции (т.к. длина равна 1, то она сокращается). Проекция вектора $\vec b$ на $\vec a$ единичной длины:  
$t = \vec a \cdot \vec b = {\vec a}^T \vec b$  
$\vec c = \vec a \cdot {(\vec a}^T \vec b)$

### Матрица поворота двуменого пространства
Предположим у нас есть некая фигура:

![](./assets/Figure_3.png)

Чтобы ее нарисовать, заданы координаты ее вершин, от которых строятся линии. Координаты заданы в виде набора векторов. Итак, координаты наших вершин заданы таким образом $\vec v_i = ({v_i}_x, {v_i}_y)^T$. Наша координатная сетка задана двумя осями - единичными ортогональными (перпендикулярными) векторами. В двумерном пространстве к вектору можно получить два перпендулярных вектора такой же длины: $perp(\vec v) = \begin{pmatrix}\mp v_y & \pm v_x \end{pmatrix}^T$ - левый и правый перпендикуляры. Берем вектор, задающим ось $X$ - $\vec{aX}=\begin{pmatrix} 1 & 0 \end{pmatrix}^T$ и правый перпендикуляр - ось $Y$ - $\vec{aX}=\begin{pmatrix} 0 & 1 \end{pmatrix}^T$.  
Получим проекции на оси при помощи наших векторов, задающих оси:  
$x = \vec{aX}^T \vec{v_i} = \begin{pmatrix} 1 & 0 \end{pmatrix}^T \vec v = v_x$  
$y = \vec{aY}^T \vec{v_i} = \begin{pmatrix} 0 & 1 \end{pmatrix}^T \vec v = v_y$  
Сюрприз - они совпадают с компонентами наших векторов, которые уже и являются проекциями вектора на оси. 
Теперь попробуем как-то изменить нашу фигуру - повернем ее на угол $\alpha$. Для этого повернем векторы $\vec{aX}$ и $\vec{aY}$, задающих оси координат. Поворот вектора $\begin{pmatrix} 1 & 0 \end{pmatrix}^T$ (ось $X$ - $\vec{aX}$) задаются косинусом и синусом угла - $\vec{aX}=rotate(\begin{pmatrix} 0 & 1 \end{pmatrix}^T, \alpha) = \begin{pmatrix} \cos(\alpha) & \sin(\alpha) \end{pmatrix}^T$. А чтобы получить вектор оси $Y$, возьмем перпендикуляр от $\vec{aX}$: $\vec{aY}=\begin{pmatrix} -\sin(\alpha) & \cos(\alpha) \end{pmatrix}^T$. Выполнив эту трансформацию, получаем новую фигуру:  
$\vec{v_i'} = \begin{pmatrix} \vec{v_i}^T \vec{aX} & \vec{v_i}^T \vec{aY} \end{pmatrix}^T$  

![$\alpha=20^\circ$](./assets/Figure_4.png)

Вектора $\vec{aX}$ и $\vec{aY}$ являются ортонормированным базисом, потому как вектора ортогональны между собой (а значит базис ортогонален), а вектора имеют единичную длину, т.е. нормированы.

Теперь мы говорим о нескольких системах координат - базовая система координат - назовем ее мировой, и локальную для нашего объекта, которую мы поворачивали. Также удобно объединить наш набор векторов в одну матрицу - $R = \begin{pmatrix} \vec{aX} & \vec{aY} \end{pmatrix} = \begin{pmatrix} \cos{\alpha} & -\sin(\alpha) \\ \sin(\alpha) & \cos(\alpha) \end{pmatrix}$  
Тогда $\vec{v_i'} = \begin{pmatrix} \vec{v_i}^T \vec{aX} & \vec{v_i}^T \vec{aY} \end{pmatrix}^T = \begin{pmatrix} \vec{aX} & \vec{aY} \end{pmatrix} \vec{v_i} = R \cdot \vec{v_i}$.
Короче $\vec{v_i'} = R \cdot \vec{v_i}$.  
Матрица $R$, состовляющая ортонормированный базис и описывающая поворот, называется матрицей поворота. Также имеет ряд полезных свойств, которые следует иметь ввиду:  
* $|R|=1|$ - определитель матрицы равен 1.
* $R^T = R^{-1}$. 
* $R^T R = R^{-1} R = I$, где $I$ - единичная матрица.  
$R^T R = \begin{pmatrix}\vec{aX} & \vec{aY}\end{pmatrix}^T \begin{pmatrix}\vec{aX} & \vec{aY}\end{pmatrix} = \begin{pmatrix}\vec{aX}^T\vec{aX} & \vec{aX}^T\vec{aY} \\ \vec{aY}^T\vec{aX} & \vec{aY}^T\vec{aY}\end{pmatrix} = \begin{pmatrix} 1 & 0 \\ 0 & 1 \end{pmatrix}$.
* $\vec{v'} = R \vec v \Rightarrow |\vec{v'}|=|\vec v|$, поворот не меняет длины вектора.
* зная $\vec{v'}$ и $R$, можем получить исходный вектор $\vec v$ - $\vec v = R^{-1} \vec{v'} = R^T \vec{v'}$. Т.е. умножая вектор на матрицу поврота мы выполняем преобразование координат вектора из локальной системы координат объекта в мировую, но также мы можем поступать и наоборот - преобразовывать мировые координаты в локальную систему координат объекта, умножая на обратную матрицу поврота. Эти моменты хорошо бы хорошо понимать.

Теперь попробуем повернуть наш объект два раза, первый раз на угол $\alpha$, второй раз на угол $\beta$. Матрицу, полученную из угла $\alpha$, обозначим как $R_a$, из угла $\beta$ - $R_b$. Распишем наше итоговое преобразование:  
$\vec{{v'}_i} = R_b R_a \vec{v_i}$. 

![$\alpha=20^\circ, \beta=10^\circ$](./assets/Figure_5.png)

Обозначим $R_c = R_b R_a$, тогда $\vec{{v'}_i} = R_c \vec{v_i}$. И из двух операций мы получили одну. Так как поворот - это линейное преобразование (описали ее при помощи одной матрицы), множество преобразований можно описать одной матрицей, что сильно упрощает над ними работу.

### Масштабирование

Масштабировать объект достаточно просто, нужно только умножить координаты точек на коефициент масштаба: $\vec{v_i'} = s \cdot \vec{v_i}$. Если мы хотим масштабировать объект на разную величину по разным осям, то формула принимает вид: $\vec{v_i'} = \begin{pmatrix} s_x \cdot {v_i}_x & s_y \cdot {v_i}_y \end{pmatrix}^T$. Для удобства переведем операцию в матричный вид: $S = \begin{pmatrix} s_x & 0 \\ 0 & s_y \end{pmatrix}, \vec{v_i'} = S \cdot \vec{v_i}$.

Теперь предположим, что нам нужно повернуть и масштабировать наш объект. Нужно отметить, что если сначала масштабировать, а затем повернуть, то результат будет отличаться, от того рузультата, где мы сначала повернули, а затем масштабировали:

Сначала поворот, а затем масштабирование по осям:
![$\alpha=20^\circ, s_x=1.5, s_y=0.5$](./assets/Figure_6.png)

Сначала масштабирование по осям, а затем поврот:
![$\alpha=20^\circ, s_x=1.5, s_y=0.5$](./assets/Figure_7.png)

Как мы видим порядок опереций играет большое значение, и его нужно обязательно учитывать.  
Также здесь мы также можем объединять матрицы преобразования в одну:  
$\vec{{v'}_i} = S R \vec{v_i}, \space T_a = S R \Rightarrow \vec{{v'}_i} = T_a \vec{v_i}$  
$\vec{{v'}_i} = R S \vec{v_i}, \space T_b = R S \Rightarrow \vec{{v'}_i} = T_b \vec{v_i}$  
$T_a \neq T_b!$

Хотя в данном случае, если $s_x = s_y$, то $T_a = T_b$. Тем не менее, с порядком преобразований нужно быть очень аккуратным. Их нельзя просто так менять местами.

### Векторное произведение векторов

Перейдем в трехмерное пространство и рассмотрим определенное на нем векторное произведение.
Векторное произведение двух векторов в трёхмерном пространстве — вектор, ортогональный к обоим исходным векторам, длина которого равна площади параллелограмма, образованного исходными векторами.

Для примера возьмем два трехмерных вектора - $\vec a$, $\vec b$. И в результате векторного произведения получим $\vec c = \vec a \times \vec b = \begin{pmatrix}a_y \cdot b_z - a_z \cdot b_y & a_z \cdot b_x - a_x \cdot b_z & a_x \cdot b_y - a_y \cdot b_x \end{pmatrix}^T$  

Визуализируем данную операцию:
![](./assets/Figure_8.png)
Здесь наши вектора $\vec a$, $\vec b$ и $\vec c$. Вектора начинаются с начала координат, обозанченной точкой $A$. Конечная точка вектора $\vec a$ - точка $B$. Конечная точка $\vec b$ - точка $C$. Параллелограмм из определения формируются точками $A$, $B$, $C$, $D$. Координаты точки $D$ найти достаточно просто - $D = \vec a + \vec b$. В итоге имеем следующие соотношения:  
* $|\vec c| = S(ABCD)$, где $S$ - площадь,
* $\vec{a}^T \cdot \vec c = 0$,
* $\vec{b}^T \cdot \vec c = 0$.

Два вектора образуют плоскость, векторное произведение позволяет получить перпендикуляр этой плоскости. Получившиеся вектора образуют образуют правую тройку векторов. Если берем обратный вектор, то получаем второй перпендикуляр к плоскости, и тройка векторов будет уже левой.

Для запоминания этой формулы удобно использовать мнемонический определитель. Здесь $i = \begin{pmatrix} 1 & 0 & 0 \end{pmatrix}^T, \space j = \begin{pmatrix} 0 & 1 & 0 \end{pmatrix}^T, \space k = \begin{pmatrix} 0 & 0 & 1 \end{pmatrix}^T$, и мы раскладываем определить по строке как сумму определителей миноров исходной матрицы $i, j, k$:
$\vec c = \vec a \times \vec b = \begin{vmatrix} (i, j, k)^T & \vec a & \vec b \end{vmatrix} = \begin{vmatrix} i & a_x & b_x \\ j & a_y & b_y \\ k & a_z & b_z \end{vmatrix} = i \cdot \begin{vmatrix} a_y & b_y \\ a_z & b_z \end{vmatrix} - j \cdot \begin{vmatrix} a_x & b_x \\ a_z & b_z \end{vmatrix} + k \cdot \begin{vmatrix} a_x & b_x \\ a_y & b_y \end{vmatrix} \space \Rightarrow$  
$\vec c = \begin{pmatrix}a_y \cdot b_z - a_z \cdot b_y & a_z \cdot b_x - a_x \cdot b_z & a_x \cdot b_y - a_y \cdot b_x \end{pmatrix}^T$

Есть еще одно удобное свойство данного произведения. Если два вектора ортогональны и нормализованы, то вектор также будет иметь единичную длину. Параллелограмм, который образуется двумя исходными векторами, станет квадратом с длинной сторон равной единице. Т.е. площадь равна единице, отсюда длина выходного вектора - единица.

### Матрица поворота трехмерного пространства

С тем, как формировать матрицу в двумерном пространстве мы разобрались. В трехмерном она формируется уже не двумя, а тремя ортогональными векторами -- $R = \begin{pmatrix} \vec{aX} & \vec{aY} & \vec{aZ} \end{pmatrix}$. По свойствам, описанным выше, можно вывести следующией отношения между этими векторам:  
* $\vec{aZ} = \vec{aX} \times \vec{aY}$
* $\vec{aX} = \vec{aY} \times \vec{aZ}$
* $\vec{aY} = \vec{aZ} \times \vec{aX}$

Вычислить эти вектора осей сложнее, чем двумерном пространстве. Рассмотрим алгоритм, который в трехмерных движках называется lookAt. Для этого нам понадобятся вектор направления взгляда - $\vec z$ и опорный вектор для оси $Y$ - $\vec y$. Сам алгоритм:
1. Обычно направление камеры совпадает с осью $Z$. Поэтому нормализуем $\vec z$ получаем ось $Z$ -- $\vec aZ = \frac{\vec z}{|\vec z|}$.
2. Получаем вектор оси $X$ -- $\vec{aX} = \frac{\vec{y} \times \vec{aZ}}{|\vec{y} \times \vec{aZ}|}$. В итоге у нас есть два нормализованных ортогональных вектора $\vec{aX}$ и $\vec{aZ}$, описывающих оси $X$ и $Z$, при этом ось $Z$ сонаправлена с входным вектором $\vec z$, а ось $X$ перпенидулярна к входному опорному вектору $\vec y$. 
3. Получаем вектор оси $Y$ из полченных $\vec{aX}$ и $\vec{aZ}$ -- $\vec{aY} = \vec{aZ} \times \vec{aX}$.
4. Получаем матрицу $R = \begin{pmatrix} \vec{aX} & \vec{aY} & \vec{aZ} \end{pmatrix}$

В трехмерных редакторах и движках в интерфейсах часто используются углы Эйлера для задания поврота. Углы Эейлера более интуитивно понятны - это три числа, обозначающие три последовательных поворота вокруг трех основных осей $X, Y, Z$. Однако, работать с ними не очень то просто. Если попробовать выразить итоговый вектор напрямую через эти повороты, то получим довольно объемную формулы, состоящую из синусов и косинусов наших углов. Есть еще пара проблем с этими углами. Первая проблема - это то, что сами по себе углы не задают однозначного поворота, так как результат зависит от того, в какой последовательности происходили повороты - $X \rightarrow Y \rightarrow Z$ или $Z \rightarrow X \rightarrow Y$ или как-то еще. Углы Ейлера - это последовательность поворотов, а как мы помним, смена порядка трансформаций меняет итоговый результат. Вторая проблема - это [gimbal lock](https://habr.com/ru/post/183116/#:~:text=%D0%A3%D0%B3%D0%BB%D1%8B%20%D0%AD%D0%B9%D0%BB%D0%B5%D1%80%D0%B0%20%D0%B8%D0%BC%D0%B5%D1%8E%D1%82%20%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE%20%D0%BD%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BA%D0%BE%D0%B2,%2C%20%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0%20%D0%BE%D1%81%D0%B5%D0%B9%2C%20%D1%81%D0%BA%D0%BB%D0%B0%D0%B4%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%80%D0%B0%D0%BC%D0%BE%D0%BA).

Внутри же трехмерные движки чаще всего используют кватернионы, которых мы касаться не будем.

Существуют разные способы задания поврота в трехмерном пространстве, и каждый имеет свои плюсы и минусы:
* Матрица поврота. С ней просто работать (т.к. это просто матрицы). Но есть логическая избыточность данных - все элементы матрицы связаны определенными условиями, так как количество элементов больше степеней свободы (12 елементов против трех степеней). Т.е. мы не можем взять матрицу и наполнить ее случайными числами, так при несоблюдении условий матрица просто не будет являться матрицей поворота.
* Углы Эйлера. Они интуитивно понятны, но работать с ними сложно.
* Вектор оси вращения и угол порота вокруг нее. Любой возможный поворот можно описать таким образом. Описание поворота вектора таким способои будет ниже.
* Вектор поворота Родрига. Это трехмерный вектор, где нормализованный вектор представляет собой ось вращения, а длина вектора угол поворота. Этот способ задания поворота похож на предыдущий способ, но количество элементов здесь равно числу степеней свободы, и элементы не связаны между собой жесткими ограничениями. И мы можем взять трехмерный вектор с абсолютно случайными числами, и любой полученный вектор будет задавать какое-то возможное вращение.

### Поворот вектора воруг заданной оси



